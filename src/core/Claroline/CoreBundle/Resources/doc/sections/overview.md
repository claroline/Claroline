[[Documentation index]][1]

Overview
========

- [Introduction](#introduction)
- [Directory structure](#directory-structure)
- [Bundles](#bundles)
- [Database](#database)
  - [Migrations](#migrations)
  - [Data fixtures](#data-fixtures)
- [Assets and views](#assets-and-views)

Introduction
------------

**Claroline** is built on top of the Symfony framework (version 2.x). It also
relies on librairies and frameworks commonly associated with Symfony, such as
Doctrine and Twig. This documentation doesn't cover the usage of those
dependencies. If you have any trouble with them, please refer to their official
documentation :

- [Symfony][2]
- [Doctrine][3]
- [Twig][4]

Sections below, and more generally this documentation, are intended to
highlight differences between Claroline and the standard Symfony distribution,
as well as the particular technical choices that have been made so far.

Directory structure
-------------------

The organization of directories in Claroline is close to the Symfony standard,
and has the same meaning :

<pre>
root
|-- app
|-- bin
|-- files
|-- src
|-- test
|-- vendor
+-- web
</pre>

The only differences are the *files* and *test* directories. The first one is
there to gather the files which are created within the platform (usually non
public files, stored with a hash name and referenced in the database). The
second is a directory used to work with arbitrary files during the test suite
process.

The *app* directory is again close to the standard one :

<pre>
app
|-- Resources
|-- build
|-- config
|-- dev
+-- logs
</pre>


You will notice two special directories :

- The *build* directory gathers configuration files for some of the quality
  insurance tools used in the project workflow (more on that below). It is also
  in this directory that the reports generated by those tools are written.
- The *dev* directory includes scripts intended to ease the development
  process.

The *app/config* directory also contains a special sub-directory named
*local* :

<pre>
app
+-- config
    +-- local
</pre>

This directory stores all the configuration files particular to a given
installation of the platform. There you will find the *parameters.yml* file, in
which some important platform parameters (like the database connection
parameters) are stored, as well as the *plugin* directory, where the plugins
are "recorded" for their integration to the kernel.

The *src* directory is, as you'd expect, the place where the bundles live.
However, in order to facilitate the distinction between core and plugin
bundles, this directory is divided into two sub-directories :

<pre>
src
|-- plugin
+-- core
</pre>


Bundles
-------

The bundles are structured in the same way than any Symfony bundle. Classicaly,
you will find in most of the bundles the usual *Controller*, *Entity*,
*Resources*, etc. directories. If you look at the bundles provided by default,
you will also often see the following two directories :

<pre>
bundle
|-- DataFixtures
+-- Migrations
</pre>

Both are related to the database and are covered in the next section.

Database
--------

Claroline use the Doctrine ORM for database interactions. It allows both a
simpler development process and a portability across the major RDBMS (see the
DBAL documentation for a list of [supported drivers][5]).

### Migrations

The ORM offers a schema generation feature based on the mapping of the
entities. However, as this method is [not recommanded][6] for database
versionning in a production environment, Claroline uses an alternative
approach, also designed by Doctrine, called [Migrations][7]. The idea is to use
separate classes, ordered by timestamps, to handle each version of the
database. Doctrine stores the current version of the schema in a dedicated
table and can execute the right migration class when a schema upgrade or
downgrade is requested. A typical migration class in Claroline looks like the
following :

```php
<?php

namespace Foo\BarBundle\Migrations;

use Claroline\CoreBundle\Library\Installation\BundleMigration;
use Doctrine\DBAL\Schema\Schema;

class Version20130101000000 extends BundleMigration
{
    /**
     * Generates/upgrades the database schema of the Foo\BarBundle to the
     * version '20130101000000' (year/month/day/hour/minute/second).
     */
    public function up(Schema $schema)
    {
        $table = $schema->createTable('some_table');
        $this->addId($table);
        $table->addColumn('number', 'integer');
        $table->addColumn('name', 'string', array('length' => 250));
    }

    /**
     * Downgrades/removes the database schema of the Foo\BarBundle.
     */
    public function down(Schema $schema)
    {
        $schema->dropTable('some_table');
    }
}
```

Of course, if the created schema is intended to work with the ORM, it must
match the mapping defined in the corresponding entities. If you follow this
rule, having the database tables of your bundle created or updated is simple as
creating a *Migrations* directory and defining some migration classes in it :

<pre>
bundle
|-- DataFixtures
+-- Migrations
    +-- Version20130101000000.php
</pre>

The execution of these migrations is part of the installation of any bundle in
the Claroline platform.

### Data fixtures

Another useful feature is the ability to load automatically some data sets in
the database, whether to provide some demo samples with a bundle or to have
data to work with in an automatic test. In Claroline, this result is acheived
using the Doctrine [Data Fixtures][8] library. A fixture is simply a class
implementing a `load` method, to which an instance of the entity manager is
passed by Doctrine when the fixture is executed. In that method, you can
therefore use the manager to persist any needed data. Example :

```php
<?php

namespace Foo\BarBundle\DataFixtures;

use Doctrine\Common\DataFixtures\AbstractFixture;
use Doctrine\Common\Persistence\ObjectManager;
use Foo\BarBundle\Entity\FooEntity;

class FooFixture extends AbstractFixture
{
    public function load(ObjectManager $manager)
    {
        $foo = new FooEntity();
        $foo->setName('bar');
        $manager->persist($foo);
        $manager->flush();
    }
}
```

The data fixtures loading is also part of the installation of every bundle in
Claroline. To benefit from this feature, simply put your fixture classes in
a *DataFixtures* directory :

<pre>
bundle
+-- DataFixtures
    +-- FooFixture.php
</pre>

Using those fixtures in a test requires to instantiate the fixture class and
provide its dependencies manually. This will be covered later in this
documentation.

Assets and views
----------------

Claroline uses a few client-side libraries. Some -- like JQuery and Bootstrap
-- are available in every page, while others -- like underscore.js or
backbone.js -- are used only in specific areas. All of them are gathered in an
bundle called [FrontEndBundle][9], which is included by default in the
platform. A javascript-compiled version of Twig, called [twigjs][10] is also
used whenever client-side templating is required.

[[Documentation index]][1]

[1]:  ../index.md
[2]:  http://symfony.com/doc/current/index.html
[3]:  http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/index.html
[4]:  http://twig.sensiolabs.org/documentation
[5]:  http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/configuration.html#driver
[6]:  http://docs.doctrine-project.org/en/2.0.x/reference/tools.html#database-schema-generation
[7]:  http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/toc.html
[8]:  https://github.com/doctrine/data-fixtures
[9]:  https://github.com/claroline/FrontEndBundle
[10]: http://jmsyst.com/libs/twig.js
