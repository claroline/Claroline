[[Documentation index]][1]

Overview
========

Claroline is built on top of the Symfony framework (version 2.x). It also relies
on librairies and frameworks commonly associated with Symfony, such as Doctrine
and Twig. This documentation doesn't cover the usage of those dependencies. If
you have any trouble with them, please refer to their official documentation :

- [Symfony][2]
- [Doctrine][3]
- [Twig][4]

Sections below, and more generally this documentation, are intended to highlight
differences between Claroline and the standard Symfony distribution, as well as
the particular technical choices that have been made so far.

Directory structure
-------------------

The organization of directories in Claroline is close to the Symfony standard,
and has the same meaning :

    - (root)
        - app
        - bin
        - files
        - src
        - test
        - vendor
        - web

The only differences are the *files* and *test* directories. The first one is
there to gather the files which are created within the platform (usually non
public files, stored with a hash name and referenced in the database). The
second is a directory used to work with arbitrary files during the test suite
process.

The *app* directory is again close to the standard one :

    - app
        - Resources
        - build
        - config
        - dev
        - logs

You will notice two special directories :

- The *build* directory gathers configuration files for some of the quality
  insurance tools used in the project workflow (more on that below). It is also
  in this directory that the reports generated by those tools are written.
- The *dev* directory includes scripts intended to ease the development process.

The *app/config* directory also contains a special sub-directory named *local* :

    - app
        - config
            - local

This directory stores all the configuration files particular to a given
installation of the platform. There you will find the *parameters.yml* file, in
which some important platform parameters (like the database connection
parameters) are stored, as well as the *plugin* directory, where the plugins are
"recorded" for their integration to the kernel.

The *src* directory is, as you'd expect, the place where the bundles live.
However, in order to facilitate the distinction between core and plugin bundles,
this directory is divided into two sub-directories :

    - src
        - plugin
        - core

Bundles
-------

The bundles are structured in the same way than any Symfony bundle. Classicaly,
you will find in most of the bundles the usual *Controller*, *Entity*,
*Resources*, etc. directories. If you look at the bundles provided by default,
you will also often see the following two directories :

    - DataFixtures
    - Migrations

Both are related to the database and are covered in the next section.

Database
--------

Claroline use the Doctrine ORM for database interactions. It allows both a
simpler development process and a portability across the major RDBMS (see the
DBAL documentation for a list of [supported drivers][5]).

### Migrations

The ORM offers a schema generation feature based on the mapping of the entities.
However, as this method is [not recommanded][6] for database versionning in a
production environment, Claroline uses an alternative approach, also designed
by Doctrine, called [Migrations][7]. The idea is to use separate classes,
ordered by timestamps, to handle each version of the database. Doctrine stores
the current version of the schema in a dedicated table and can execute the right
migration class when a schema upgrade or downgrade is requested. A typical
migration class in Claroline looks like the following :

    <?php

    namespace Foo\BarBundle\Migrations;

    use Claroline\CoreBundle\Library\Installation\BundleMigration;
    use Doctrine\DBAL\Schema\Schema;

    class Version20130101000000 extends BundleMigration
    {
        /**
         * Generates/upgrades the database schema of the Foo\BarBundle to the
         * version '20130101000000' (year/month/day/hour/minute/second).
         */
        public function up(Schema $schema)
        {
            $table = $schema->createTable('some_table');
            $this->addId($table);
            $table->addColumn('number', 'integer');
            $table->addColumn('name', 'string', array('length' => 250));
        }

        /**
         * Downgrades/removes the database schema of the Foo\BarBundle.
         */
        public function down(Schema $schema)
        {
            $schema->dropTable('some_table');
        }
    }

Of course, if the created schema is intended to work with the ORM, it must match
the mapping defined in the corresponding entities. If you follow this rule,
having the database tables of your bundle created or updated is simple as
creating a *Migrations* directory and defining some migration classes in it :

    - (bundle)
        - Migrations
            - Version20130101000000.php

The execution of these migrations is part of the installation of any bundle in
the Claroline platform.

### Data fixtures

Another useful feature is the ability to load automatically some data sets in
the database, whether to provide some demo samples with a bundle or to have data
to work with in an automatic test. In Claroline, this result is acheived using
the Doctrine [Data Fixtures][8] library. A fixture is simply a class
implementing a `load` method, to which an instance of the entity manager is
passed by Doctrine when the fixture is executed. In that method, you can
therefore use the manager to persist any needed data. Example :

    <?php

    namespace Foo\BarBundle\DataFixtures;

    use Doctrine\Common\DataFixtures\AbstractFixture;
    use Doctrine\Common\Persistence\ObjectManager;
    use Foo\BarBundle\Entity\FooEntity;

    class FooFixture extends AbstractFixture
    {
        public function load(ObjectManager $manager)
        {
            $foo = new FooEntity();
            $foo->setName('bar');
            $manager->persist($foo);
            $manager->flush();
        }
    }

The data fixtures loading is also part of the installation of every bundle in
Claroline. To benefit from this feature, simply put your fixture classes in
a *DataFixtures* directory :

    - (bundle)
        - DataFixtures
            - FooFixture.php

Using those fixtures in a test requires to instantiate the fixture class and
provide its dependencies manually. This will be covered later in this
documentation.

Assets and views
----------------

Claroline uses a few client-side libraries. Some -- like JQuery and Bootstrap --
are available in every page, while others -- like underscore.js or backbone.js
-- are used only in specific areas. All of them are gathered in an bundle called
[FrontEndBundle][9], which is included by default in the platform. A
javascript-compiled version of Twig, called [twigjs][10] is also used whenever
client-side templating is required.


[1]:  ../index.md
[2]:  http://symfony.com/doc/current/index.html
[3]:  http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/index.html
[4]:  http://twig.sensiolabs.org/documentation
[5]:  http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/configuration.html#driver
[6]:  http://docs.doctrine-project.org/en/2.0.x/reference/tools.html#database-schema-generation
[7]:  http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/toc.html
[8]:  https://github.com/doctrine/data-fixtures
[9]:  https://github.com/claroline/FrontEndBundle
[10]: http://jmsyst.com/libs/twig.js